<!DOCTYPE html>

<html lang="ja">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <title>Pong</title>
  <script crossorigin src="https://cdnjs.cloudflare.com/ajax/libs/react/18.2.0/umd/react.production.min.js"></script>
  <script crossorigin src="https://cdnjs.cloudflare.com/ajax/libs/react-dom/18.2.0/umd/react-dom.production.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/babel-standalone/7.23.5/babel.min.js"></script>
  <script src="https://cdn.tailwindcss.com"></script>
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet">
  <style>
    body { margin: 0; overflow: hidden; }
    .retro-font { font-family: 'Press Start 2P', monospace; }
  </style>
</head>
<body>
  <!-- Version: 3.0 - Player-fixed colors, complement collision rule, grey ball as hazard -->
  <div id="root"></div>

  <script type="text/babel">
    const { useState, useEffect, useRef } = React;

    function PongGame() {
      const canvasRef = useRef(null);
      const audioContextRef = useRef(null);
      const [gameState, setGameState] = useState('menu');
      const [scores, setScores] = useState({ left: 0, right: 0 });
      const [countdown, setCountdown] = useState(3);
      const [blinkVisible, setBlinkVisible] = useState(true);
      const [blinkingPaddle, setBlinkingPaddle] = useState(null);
      const [soundEnabled, setSoundEnabled] = useState(true);
      const [gameMode, setGameMode] = useState('split');
      const [ballCount, setBallCount] = useState(1);
      const [gameSpeed, setGameSpeed] = useState('normal');
      
      const gameRef = useRef({
        balls: [{ x: 500, y: 300, vx: 5, vy: 3, size: 12, isMain: true, color: '#ffffff' }],
        paddles: {
          left: { x: 50, y: 250, width: 20, height: 120 },
          right: { x: 930, y: 250, width: 20, height: 120 }
        },
        touches: {},
        canvasWidth: 1000,
        canvasHeight: 600,
        hitCount: 0
      });

      // Initialize audio context
      const initAudio = () => {
        if (!audioContextRef.current) {
          audioContextRef.current = new (window.AudioContext || window.webkitAudioContext)();
        }
      };

      // Sound effects
      const playSound = (type) => {
        if (!soundEnabled || !audioContextRef.current) return;
        
        const ctx = audioContextRef.current;
        const oscillator = ctx.createOscillator();
        const gainNode = ctx.createGain();
        
        oscillator.connect(gainNode);
        gainNode.connect(ctx.destination);
        
        switch(type) {
          case 'paddle':
            oscillator.frequency.value = 220;
            gainNode.gain.value = 0.1;
            oscillator.start();
            oscillator.stop(ctx.currentTime + 0.05);
            break;
          case 'paddle_white':
            oscillator.frequency.value = 350;
            gainNode.gain.value = 0.12;
            oscillator.start();
            oscillator.stop(ctx.currentTime + 0.05);
            break;
          case 'wall':
            oscillator.frequency.value = 180;
            gainNode.gain.value = 0.08;
            oscillator.start();
            oscillator.stop(ctx.currentTime + 0.05);
            break;
          case 'ball':
            oscillator.frequency.value = 250;
            gainNode.gain.value = 0.06;
            oscillator.start();
            oscillator.stop(ctx.currentTime + 0.04);
            break;
          case 'ball_white':
            oscillator.frequency.value = 400;
            gainNode.gain.value = 0.08;
            oscillator.start();
            oscillator.stop(ctx.currentTime + 0.04);
            break;
          case 'score':
            oscillator.frequency.value = 150;
            gainNode.gain.value = 0.15;
            oscillator.start();
            oscillator.stop(ctx.currentTime + 0.2);
            break;
          case 'go':
            oscillator.frequency.value = 440;
            gainNode.gain.value = 0.12;
            oscillator.start();
            oscillator.stop(ctx.currentTime + 0.1);
            break;
          case 'merge':
            oscillator.frequency.value = 280;
            gainNode.gain.value = 0.1;
            oscillator.start();
            oscillator.stop(ctx.currentTime + 0.08);
            break;
          case 'spawn_white':
            oscillator.frequency.value = 523;
            gainNode.gain.value = 0.15;
            oscillator.start();
            oscillator.stop(ctx.currentTime + 0.1);
            break;
          case 'spawn_grey':
            oscillator.frequency.value = 100;
            gainNode.gain.value = 0.15;
            oscillator.start();
            oscillator.stop(ctx.currentTime + 0.15);
            break;
        }
      };

      // Color collision logic
      const checkCollision = (color1, color2) => {
        // Same color -> complement
        if (color1 === color2) {
          const complement = {
            '#ff4444': '#44ffff',
            '#44ff44': '#ff44ff',
            '#4444ff': '#ffff44',
            '#ffff44': '#4444ff',
            '#ff44ff': '#44ff44',
            '#44ffff': '#ff4444',
            '#ffffff': '#888888',
            '#888888': '#ffffff'
          };
          return { type: 'complement', color: complement[color1] };
        }

        const parseColor = (hex) => ({
          r: hex.slice(1, 3),
          g: hex.slice(3, 5),
          b: hex.slice(5, 7)
        });
        
        const c1 = parseColor(color1);
        const c2 = parseColor(color2);
        
        // Check ff component overlap
        const hasOverlap = 
          (c1.r === 'ff' && c2.r === 'ff') ||
          (c1.g === 'ff' && c2.g === 'ff') ||
          (c1.b === 'ff' && c2.b === 'ff');
        
        // Grey always bounces (has no 'ff' components)
        if (color1 === '#888888' || color2 === '#888888') {
          return { type: 'bounce' };
        }
        
        if (hasOverlap) {
          return { type: 'bounce' };
        } else {
          // OR operation for new color
          const newR = (c1.r === 'ff' || c2.r === 'ff') ? 'ff' : '44';
          const newG = (c1.g === 'ff' || c2.g === 'ff') ? 'ff' : '44';
          const newB = (c1.b === 'ff' || c2.b === 'ff') ? 'ff' : '44';
          return { 
            type: 'merge', 
            color: `#${newR}${newG}${newB}` 
          };
        }
      };

      const toggleSound = () => {
        if (!soundEnabled) {
          initAudio();
        }
        setSoundEnabled(!soundEnabled);
      };

      const toggleMode = () => {
        setGameMode(prev => prev === 'standard' ? 'split' : 'standard');
      };

      const toggleSpeed = () => {
        setGameSpeed(prev => prev === 'normal' ? 'slow' : 'normal');
      };

      const startGame = () => {
        initAudio();
        setCountdown(3);
        setGameState('countdown');
      };

      // Countdown logic
      useEffect(() => {
        if (gameState === 'countdown') {
          if (countdown > 0) {
            const timer = setTimeout(() => {
              setCountdown(countdown - 1);
            }, 1000);
            return () => clearTimeout(timer);
          } else {
            playSound('go');
            setGameState('playing');
          }
        }
      }, [countdown, gameState]);

      // Blink effect logic for score
      useEffect(() => {
        if (gameState === 'paused' && blinkingPaddle) {
          let count = 0;
          setBlinkVisible(false);
          playSound('score');
          
          const interval = setInterval(() => {
            count++;
            setBlinkVisible(prev => !prev);
            
            if (count >= 6) {
              clearInterval(interval);
              setBlinkVisible(true);
              setBlinkingPaddle(null);
              
              // Reset balls and resume game
              const game = gameRef.current;
              game.balls = [{ 
                x: game.canvasWidth / 2, 
                y: game.canvasHeight / 2, 
                vx: (Math.random() > 0.5 ? 1 : -1) * 5, 
                vy: (Math.random() - 0.5) * 6, 
                size: 12, 
                isMain: true, 
                color: '#ffffff' 
              }];
              game.hitCount = 0;
              setBallCount(1);
              
              setGameState('playing');
            }
          }, 150);
          
          return () => clearInterval(interval);
        }
      }, [gameState, blinkingPaddle]);

      // Main game loop
      useEffect(() => {
        const canvas = canvasRef.current;
        if (!canvas) return;
        
        const ctx = canvas.getContext('2d');
        const game = gameRef.current;
        
        let animationId;
        const gameLoop = () => {
          if (gameState !== 'playing') {
            draw();
            if (gameState === 'paused') {
              animationId = requestAnimationFrame(gameLoop);
            }
            return;
          }
          
          // Calculate speed multiplier
          let speedMultiplier = gameSpeed === 'slow' ? 0.5 : 1.0;
          
          // Move all balls
          game.balls.forEach(ball => {
            ball.x += ball.vx * speedMultiplier;
            ball.y += ball.vy * speedMultiplier;
          });
          
          // Wall collision for all balls
          game.balls.forEach(ball => {
            // Top/bottom walls
            if (ball.y - ball.size <= 0 || ball.y + ball.size >= game.canvasHeight) {
              ball.vy *= -1;
              playSound('wall');
            }
            
            // Left/right walls (only for non-main balls)
            if (!ball.isMain) {
              if (ball.x - ball.size <= 0 || ball.x + ball.size >= game.canvasWidth) {
                ball.vx *= -1;
                playSound('wall');
              }
            }
          });
          
          // Ball-to-ball collision (only in split mode)
          if (gameMode === 'split') {
            const ballsToRemove = new Set();
            const ballsToAdd = [];
            
            for (let i = 0; i < game.balls.length; i++) {
              if (ballsToRemove.has(i)) continue;
              
              for (let j = i + 1; j < game.balls.length; j++) {
                if (ballsToRemove.has(j)) continue;
                
                const b1 = game.balls[i];
                const b2 = game.balls[j];
                const dx = b2.x - b1.x;
                const dy = b2.y - b1.y;
                const distance = Math.sqrt(dx * dx + dy * dy);
                const minDist = b1.size + b2.size;
                
                if (distance < minDist) {
                  const collisionResult = checkCollision(b1.color, b2.color);
                  
                  if (collisionResult.type === 'complement') {
                    // Create complement ball
                    const isNewMain = collisionResult.color === '#ffffff';
                    const isGrey = collisionResult.color === '#888888';
                    
                    ballsToAdd.push({
                      x: (b1.x + b2.x) / 2,
                      y: (b1.y + b2.y) / 2,
                      vx: b1.vx + b2.vx,
                      vy: b1.vy + b2.vy,
                      size: 12,
                      isMain: isNewMain,
                      color: collisionResult.color
                    });
                    ballsToRemove.add(i);
                    ballsToRemove.add(j);
                    playSound('merge');
                    
                    if (isNewMain) {
                      playSound('spawn_white');
                    } else if (isGrey) {
                      playSound('spawn_grey');
                    }
                  } else if (collisionResult.type === 'merge') {
                    // Create merged ball
                    const isNewMain = collisionResult.color === '#ffffff';
                    ballsToAdd.push({
                      x: (b1.x + b2.x) / 2,
                      y: (b1.y + b2.y) / 2,
                      vx: b1.vx + b2.vx,
                      vy: b1.vy + b2.vy,
                      size: 12,
                      isMain: isNewMain || b1.isMain || b2.isMain,
                      color: collisionResult.color
                    });
                    ballsToRemove.add(i);
                    ballsToRemove.add(j);
                    playSound('merge');
                    
                    if (isNewMain) {
                      playSound('spawn_white');
                    }
                  } else {
                    // Bounce - elastic collision
                    const angle = Math.atan2(dy, dx);
                    const sin = Math.sin(angle);
                    const cos = Math.cos(angle);
                    
                    // Separate balls
                    const overlap = minDist - distance;
                    b1.x -= overlap * cos * 0.5;
                    b1.y -= overlap * sin * 0.5;
                    b2.x += overlap * cos * 0.5;
                    b2.y += overlap * sin * 0.5;
                    
                    // Swap velocities
                    const tempVx = b1.vx;
                    const tempVy = b1.vy;
                    b1.vx = b2.vx;
                    b1.vy = b2.vy;
                    b2.vx = tempVx;
                    b2.vy = tempVy;
                    
                    // Play appropriate sound based on white ball involvement
                    if (b1.color === '#ffffff' || b2.color === '#ffffff') {
                      playSound('ball_white');
                    } else {
                      playSound('ball');
                    }
                  }
                  
                  break;
                }
              }
            }
            
            // Remove marked balls
            if (ballsToRemove.size > 0) {
              game.balls = game.balls.filter((_, idx) => !ballsToRemove.has(idx));
            }
            
            // Add new merged balls
            if (ballsToAdd.length > 0) {
              game.balls.push(...ballsToAdd);
            }
          }
          
          // Update ball count
          setBallCount(game.balls.length);
          
          // Paddle collision for all balls
          game.balls.forEach(ball => {
            // Check for grey ball hitting paddle - this is a MISS
            if (ball.color === '#888888') {
              // Left paddle
              if (ball.x - ball.size <= game.paddles.left.x + game.paddles.left.width &&
                  ball.y >= game.paddles.left.y &&
                  ball.y <= game.paddles.left.y + game.paddles.left.height &&
                  ball.vx < 0) {
                // P1 loses a point
                setScores(prev => {
                  const newScores = { ...prev, right: prev.right + 1 };
                  if (newScores.right >= 11) {
                    setGameState('finished');
                  } else {
                    setBlinkingPaddle('left');
                    setGameState('paused');
                  }
                  return newScores;
                });
                return;
              }
              
              // Right paddle
              if (ball.x + ball.size >= game.paddles.right.x &&
                  ball.y >= game.paddles.right.y &&
                  ball.y <= game.paddles.right.y + game.paddles.right.height &&
                  ball.vx > 0) {
                // P2 loses a point
                setScores(prev => {
                  const newScores = { ...prev, left: prev.left + 1 };
                  if (newScores.left >= 11) {
                    setGameState('finished');
                  } else {
                    setBlinkingPaddle('right');
                    setGameState('paused');
                  }
                  return newScores;
                });
                return;
              }
            }
            
            // Normal paddle collision (non-grey balls)
            if (ball.color !== '#888888') {
              // Left paddle
              if (ball.x - ball.size <= game.paddles.left.x + game.paddles.left.width &&
                  ball.y >= game.paddles.left.y &&
                  ball.y <= game.paddles.left.y + game.paddles.left.height &&
                  ball.vx < 0) {
                ball.vx *= -1.1;
                ball.vy += (Math.random() - 0.5) * 2;
                
                // Play appropriate sound
                if (ball.color === '#ffffff') {
                  playSound('paddle_white');
                } else {
                  playSound('paddle');
                }
                
                // Spawn new ball if main ball, split mode, after warmup, and under limit
                if (gameMode === 'split' && ball.isMain && game.hitCount >= 2 && game.balls.length < 99) {
                  game.balls.push({
                    x: ball.x,
                    y: ball.y,
                    vx: (Math.random() - 0.5) * 8,
                    vy: (Math.random() - 0.5) * 8,
                    size: 12,
                    isMain: false,
                    color: '#ff4444' // P1 spawns red
                  });
                }
                game.hitCount++;
              }
              
              // Right paddle
              if (ball.x + ball.size >= game.paddles.right.x &&
                  ball.y >= game.paddles.right.y &&
                  ball.y <= game.paddles.right.y + game.paddles.right.height &&
                  ball.vx > 0) {
                ball.vx *= -1.1;
                ball.vy += (Math.random() - 0.5) * 2;
                
                // Play appropriate sound
                if (ball.color === '#ffffff') {
                  playSound('paddle_white');
                } else {
                  playSound('paddle');
                }
                
                // Spawn new ball if main ball, split mode, after warmup, and under limit
                if (gameMode === 'split' && ball.isMain && game.hitCount >= 2 && game.balls.length < 99) {
                  game.balls.push({
                    x: ball.x,
                    y: ball.y,
                    vx: (Math.random() - 0.5) * 8,
                    vy: (Math.random() - 0.5) * 8,
                    size: 12,
                    isMain: false,
                    color: '#4444ff' // P2 spawns blue
                  });
                }
                game.hitCount++;
              }
            }
          });
          
          // Check if all main balls are gone
          const mainBalls = game.balls.filter(b => b.isMain);
          if (mainBalls.length === 0 && game.balls.length > 0) {
            // Reset immediately without score change
            game.balls = [{ 
              x: game.canvasWidth / 2, 
              y: game.canvasHeight / 2, 
              vx: (Math.random() > 0.5 ? 1 : -1) * 5, 
              vy: (Math.random() - 0.5) * 6, 
              size: 12, 
              isMain: true, 
              color: '#ffffff' 
            }];
            game.hitCount = 0;
            setBallCount(1);
          }
          
          // Score detection (only main balls)
          const scoringBall = mainBalls.find(b => b.x < 0 || b.x > game.canvasWidth);
          if (scoringBall) {
            if (scoringBall.x < 0) {
              setScores(prev => {
                const newScores = { ...prev, right: prev.right + 1 };
                if (newScores.right >= 11) {
                  setGameState('finished');
                } else {
                  setBlinkingPaddle('left');
                  setGameState('paused');
                }
                return newScores;
              });
            } else {
              setScores(prev => {
                const newScores = { ...prev, left: prev.left + 1 };
                if (newScores.left >= 11) {
                  setGameState('finished');
                } else {
                  setBlinkingPaddle('right');
                  setGameState('paused');
                }
                return newScores;
              });
            }
          }
          
          draw();
          animationId = requestAnimationFrame(gameLoop);
        };
        
        const draw = () => {
          ctx.fillStyle = '#000';
          ctx.fillRect(0, 0, game.canvasWidth, game.canvasHeight);
          
          ctx.strokeStyle = '#444';
          ctx.setLineDash([10, 10]);
          ctx.beginPath();
          ctx.moveTo(game.canvasWidth / 2, 0);
          ctx.lineTo(game.canvasWidth / 2, game.canvasHeight);
          ctx.stroke();
          ctx.setLineDash([]);
          
          ctx.fillStyle = '#fff';
          if (blinkingPaddle !== 'left' || blinkVisible) {
            ctx.fillRect(game.paddles.left.x, game.paddles.left.y, game.paddles.left.width, game.paddles.left.height);
          }
          if (blinkingPaddle !== 'right' || blinkVisible) {
            ctx.fillRect(game.paddles.right.x, game.paddles.right.y, game.paddles.right.width, game.paddles.right.height);
          }
          
          if (!blinkingPaddle || blinkVisible) {
            game.balls.forEach(ball => {
              ctx.fillStyle = ball.color;
              ctx.beginPath();
              ctx.arc(ball.x, ball.y, ball.size, 0, Math.PI * 2);
              ctx.fill();
            });
          }
        };
        
        const handleTouchStart = (e) => {
          e.preventDefault();
          for (let touch of e.changedTouches) {
            game.touches[touch.identifier] = {
              x: touch.clientX,
              y: touch.clientY,
              startY: touch.clientY
            };
          }
        };
        
        const handleTouchMove = (e) => {
          e.preventDefault();
          const rect = canvas.getBoundingClientRect();
          
          for (let touch of e.changedTouches) {
            if (game.touches[touch.identifier]) {
              const touchX = touch.clientX - rect.left;
              const touchY = touch.clientY - rect.top;
              
              const scaleX = game.canvasWidth / rect.width;
              const scaleY = game.canvasHeight / rect.height;
              
              const scaledX = touchX * scaleX;
              const scaledY = touchY * scaleY;
              
              if (scaledX < game.canvasWidth / 2) {
                game.paddles.left.y = Math.max(0, Math.min(
                  game.canvasHeight - game.paddles.left.height,
                  scaledY - game.paddles.left.height / 2
                ));
              } else {
                game.paddles.right.y = Math.max(0, Math.min(
                  game.canvasHeight - game.paddles.right.height,
                  scaledY - game.paddles.right.height / 2
                ));
              }
              
              game.touches[touch.identifier] = { x: touchX, y: touchY };
            }
          }
        };
        
        const handleTouchEnd = (e) => {
          e.preventDefault();
          for (let touch of e.changedTouches) {
            delete game.touches[touch.identifier];
          }
        };
        
        canvas.addEventListener('touchstart', handleTouchStart);
        canvas.addEventListener('touchmove', handleTouchMove);
        canvas.addEventListener('touchend', handleTouchEnd);
        
        if (gameState === 'playing' || gameState === 'paused') {
          gameLoop();
        }
        
        return () => {
          cancelAnimationFrame(animationId);
          canvas.removeEventListener('touchstart', handleTouchStart);
          canvas.removeEventListener('touchmove', handleTouchMove);
          canvas.removeEventListener('touchend', handleTouchEnd);
        };
      }, [gameState, blinkVisible, blinkingPaddle, soundEnabled, gameMode, gameSpeed]);
      
      const resetGame = () => {
        setScores({ left: 0, right: 0 });
        setGameState('menu');
        setBlinkVisible(true);
        setBlinkingPaddle(null);
        const game = gameRef.current;
        game.balls = [{ x: 500, y: 300, vx: 5, vy: 3, size: 12, isMain: true, color: '#ffffff' }];
        game.hitCount = 0;
        setBallCount(1);
      };

      return (
        <div className="flex flex-col items-center justify-start min-h-screen bg-gray-900 p-2 pt-4">
          <div className="mb-3 flex justify-between items-center w-full max-w-4xl px-8">
            <div className="text-white text-5xl font-bold retro-font">{scores.left}</div>
            <div className="text-white text-5xl font-bold retro-font">{scores.right}</div>
          </div>
          
          <div className="relative w-full max-w-full">
            <canvas
              ref={canvasRef}
              width={1000}
              height={600}
              className="border-4 border-gray-700 touch-none w-full max-w-full"
              style={{ maxHeight: '70vh', display: 'block', margin: '0 auto' }}
            />
            
            {gameState === 'menu' && (
              <div className="absolute inset-0 flex items-center justify-center bg-black bg-opacity-80">
                <button
                  onClick={startGame}
                  className="bg-blue-500 hover:bg-blue-600 text-white font-bold py-3 px-6 rounded text-xl retro-font"
                >
                  New Game
                </button>
              </div>
            )}
            
            {gameState === 'countdown' && (
              <div className="absolute inset-0 flex items-center justify-center">
                <div className="text-white text-6xl font-bold retro-font">
                  {countdown > 0 ? countdown : 'GO!'}
                </div>
              </div>
            )}
            
            {gameState === 'finished' && (
              <div className="absolute inset-0 flex items-center justify-center bg-black bg-opacity-80">
                <div className="text-center">
                  <div className="text-white text-4xl mb-6 retro-font">
                    {scores.left >= 11 ? 'P1' : 'P2'} Wins!
                  </div>
                  <button
                    onClick={resetGame}
                    className="bg-blue-500 hover:bg-blue-600 text-white font-bold py-3 px-6 rounded text-xl retro-font"
                  >
                    New Game
                  </button>
                </div>
              </div>
            )}
          </div>
          
          <div className="mt-1 mb-8 flex justify-between items-center w-full max-w-4xl px-8 text-gray-400 text-xs retro-font">
            <div>P1</div>
            <div className="flex gap-4 items-center">
              <button 
                onClick={toggleSound}
                className="hover:text-gray-300 cursor-pointer"
              >
                SOUND: {soundEnabled ? 'ON' : 'OFF'}
              </button>
              <button 
                onClick={toggleMode}
                className="hover:text-gray-300 cursor-pointer"
              >
                MODE: {gameMode.toUpperCase()}
              </button>
              <button 
                onClick={toggleSpeed}
                className="hover:text-gray-300 cursor-pointer"
              >
                SPEED: {gameSpeed.toUpperCase()}
              </button>
              <span className="text-gray-600">BALLS: {ballCount}</span>
              <span className="text-gray-600">v3.0</span>
            </div>
            <div>P2</div>
          </div>
        </div>
      );
    }

    const root = ReactDOM.createRoot(document.getElementById('root'));
    root.render(<PongGame />);
  </script>

</body>
</html>